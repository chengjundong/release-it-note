# 系统设计目的
* 设计为production环境，为真实世界服务的系统
* 不要设计为了通过QA测试的系统

# 开始设计
* 考虑开发成本
* 考虑下游系统的影响
* 避免“一次开发，终身维护”的项目设计
* 最初的设计决定，也是最后，最难以修改的决定
* 系统设计的初稿，是选team
* 越是对整体系统缺乏概念的team，越容易做出最无法修改的决定

# “象牙塔”架构师与实干派架构师
## “象牙塔”架构师
* 更关注系统的顶层抽象
* 关于实现，全部参考“公司标准”
* 程序员们也乐在其中，因为他们总是在用最衬手的武器
* 不用操心程序员如何工作；同样，也不用操心用户
* 设计一旦落石，基本都不可改。每个组件都stick to their role
## 实干派架构师
* 更关注细节，诸如CPU，内存，网络带宽需求
* 除了功能设计，会关心如何部署，需要收集哪些指标
* 明白系统是需要持续演进的，并且设计之初并保留了这种可能
* 熟知哪些组件在什么情况下需要扩展，需要替换。如，访问量激增等。

# 稳定性 Stability
## 故障恢复
* 遇到production故障，第一要务是重启服务
* 重启方法1：重启所有服务。就像医生对于一个发烧的病人尝试所有已知的治疗发烧病因的方法，但是由于发烧的病因太多，这个很耽误时间。
* 重启方法2：通过线索排查，精准定位到有问题的服务。这需要提前准备并测试，日志和分析报告，以及经验。
## 事后分析
* 一般从最后一次change开始着手
* 通常，处理一个事故后大家的看法，同处理事故本身一样重要
## 测试
* 一个可以复现bug的测试，应该作为bug fix的指标
## Cynical Software
* Don't trust anyone, even itself
* Expect bad things to happen and never suprise
* Won't keep "intimate" relationship with other system
## 术语
### transaction
有别于数据库事务，这里的transcation是指对于系统来说，一个最小的工作单元（unit of work）。举例，对于电子商务系统，一个transcation就是用户购买一个商品并完成支付。整个过程可能涉及多个系统，甚至是外部系统。
### impulse
脉冲，来自机械工程的词汇。特指对于系统的瞬时冲击，比如一条庆祝网站生日的tweet，会带来一波很高的瞬时流量。这就是一次冲击。
### stress
压力，同样来自机械工程的词汇。指对于系统，长时间的影响。比如一段时间内，来自银行系统的反馈速度很慢，会导致支付环节有很大的压力。
### 不出错时间
系统应该在很长一段时间内，一直可以处理transaction。如何定义很长一段时间呢？通用标准是code deployment的间隔。举例来说，如果一个系统1周部署一次，就不需要考虑是否可以持续运行2年不重启。
## Longevity Test
对于系统来说，最致命的是运行一段时间后的内存泄漏和数据量增长  
这两点很难在测试环境测试到
- 开发环境：不可能长时间运行
- QA环境：运行时间稍长，但相比production还是不够长，数据量也不可能同日而语
- 压测环境：运行时间较短

如果可以的，搭建一套开发环境，保证数据隔离性。使用JMeter或者Marathon之类的工具，对其进行长时间压测。  
脚本编写需要一点技巧，在某些时间段可以减少压力，以便模拟production上某些时间段的低traffic情况（半夜）

如果做不到上述的，那么production就是lonevity test的环境了 :-)

## Stop the crack
系统错误就像盘子上的裂缝。一开始是一条，后来越来越多，直到碎裂。  
系统必须考虑如何在一开始就发现并制止failure progatation。  
耦合越紧，越有可能发生错误传递，由一个小错误，最终导致整个系统崩溃。  

# 不稳定的设计模式
## 系统集成
1. REST API中，避免使用client lib，将response直接转成domain object。应该确认response是否符合你的预期，然后进行转换。
2. 避免使用client lib的另一个好处是，你可以自己控制诸如超时，endpoint等

## 连锁反应
1. 在水平扩展的架构中，当一台服务器宕机之后，很容易引起其他服务器陆续宕机
2. 连锁反应的特点是：**每台服务器的宕机时间间隔，呈现出递减趋势**
  - 第一台宕机 到 第二台宕机，需要5分钟
  - 第二台宕机 到 第三台宕机，只需要3分钟
3. 连锁反应起因1： 内存泄漏。当剩余机器pick了宕机服务的流量后，更容易发生内存泄漏了
4. 连锁反应起因2： 死锁等traffic有关的问题。当剩余机器pick了宕机服务的流量后，更容易发生死锁了
5. 在Cloud环境中，scalar能否快速切断宕机的机器，并且重新挂载新的node，成为对付这个问题的关键
6. Bulkhead(隔离壁) 模式，可以避免连锁反应，但是没法拯救宕机服务器上的流量
7. 对于client端，应该采用断路器。避免下游出现宕机引起的连锁反应后，对下游继续增加压力

## 线程阻塞
1. 开发阶段，几乎不可能测试到大量并发情况下才会出现的阻塞现象。需要找到一种，各个thread都能获取数据的方法，而不是互相block
2. 对于domain object，尽量使其immutable，就不需要为其加锁了。使用[CQRS模式](https://martinfowler.com/bliki/CQRS.html) 避免并发操作的问题，其被大量应用于Event Sourcing的系统中

## 缓存
1. monitor cache size
2. monitor hit rate
3. 避免cache一些很容易创建的对象 （创建cost很小）
4. 缓存应该使用weak reference，以便系统在memory不足时予以回收
5. 防止 dogpile，即缓存过期时正好遇上大量request。此时需要采用first one策略，即只有一个访问可以到达数据库，其他的会被锁block。当访问数据的结果返回后，写入cache中，后续得到锁的thread需要先检查cache。通常，使用semaphore lock。
6. 访问资源时，需要合理设置timeout
7. blocked thread常发生于集成测试的结合处
